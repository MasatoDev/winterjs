async function e(e){try{try{new TextDecoder("invalid-encoding");console.error("Failed: The constructor should throw a RangeError for an invalid encoding.")}catch(e){if(!(e instanceof RangeError))throw new Error("Failed: The error thrown is not a RangeError.");console.log("Passed: Constructor throws RangeError for invalid encoding as expected.")}try{new TextDecoder("utf-8")}catch(e){throw new Error("Failed: The constructor should not throw an error for a valid encoding.")}try{let e=new TextDecoder("utf-8"),t="",r="This is the complete text from which we will take chunks.";const s=function*(e){let t=0;for(;t<e.length;){const r=e.slice(t,t+10);t+=10;const s=(new TextEncoder).encode(r);yield s}}(r);for(let r=s.next();!r.done;r=s.next()){const s=r.value;t+=e.decode(s,{stream:!0})}if(t!==r)throw new Error("Failed: The decoded string does not match the source string.")}catch(e){throw new Error(`Failed: ${e.message}`)}const e=new Uint8Array([255,255,255]);try{new TextDecoder("utf-8",{fatal:!0}).decode(e),console.error("Failed: Decoding should throw a TypeError in fatal error mode.")}catch(e){if(!(e instanceof TypeError))throw new Error("Failed: The error thrown is not a TypeError.");console.log("Passed: TypeError thrown in fatal error mode as expected.")}return new Response("All tests passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}}async function t(e){const t=(e,t)=>{if(!e)throw new Error(t||"Assertion failed")};try{try{let e="";const o=new TransformStream({transform(e,t){t.enqueue(e.toUpperCase())}}),n=new ReadableStream({start(e){e.enqueue("Hello, "),e.enqueue("Wasmer!"),e.close()}}),a=new WritableStream({write(t){e+=t}});await n.pipeThrough(o).pipeTo(a),t((r=e)===(s="HELLO, WASMER!"),`Unexpected result from transform stream. Expected 'HELLO, WASMER!' but got ${e}`||`Expected ${s} but got ${r}`)}catch(e){t(!1,`TransformStream test failed: ${e}`)}return new Response("All Tests Passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}var r,s}function r(r){const s=new URL(r.url).pathname;return s.startsWith("/1-hello")?async function(e){return new Response("hello")}():s.startsWith("/2-blob")?async function(e){try{const e=new Blob(["Hello, world!"],{type:"text/plain"}),t=await e.text();return new Response(t,{headers:{"Content-Type":e.type,"Content-Length":e.size.toString()}})}catch(e){return new Response(e.message,{status:500})}}():s.startsWith("/3-headers")?async function(e){const t=new URL(e.url).pathname,r=new Headers({"Content-Type":"text/plain","X-Custom-Header":"CustomValue"});if(t.includes("/append"))return r.append("X-Appended-Header","AppendedValue"),new Response("Header appended",{headers:r});if(t.includes("/delete"))return r.delete("X-Custom-Header"),new Response("Header deleted",{headers:r});if(t.includes("/get")){const e=r.get("Content-Type");return new Response(`Content-Type is ${e}`,{headers:r})}if(t.includes("/has")){const e=r.has("Content-Type");return new Response(`Has Content-Type: ${e}`,{headers:r})}if(t.includes("/set"))return r.set("Content-Type","text/html"),new Response("Content-Type set to text/html",{headers:r});if(t.includes("/iterate")){let e="";for(const[t,s]of r)e+=`${t}: ${s}\n`;return new Response(`Headers iterated:\n${e}`,{headers:r})}let s="";for(const[e,t]of r)s+=`${e}: ${t}\n`;return new Response(`All Headers:\n${s}`,{headers:r})}(r):s.startsWith("/4-request")?async function(e){try{new Request(e)}catch(e){let t="Error while cloning the request\n";return t+=e.message,new Response(t,{status:500})}try{newRequest=new Request(newRequest,{method:"POST",headers:new Headers({"X-Test-Header":"TestValue"}),referrer:"no-referrer",mode:"cors",credentials:"omit",cache:"default",redirect:"follow",integrity:"",keepalive:!1,signal:null,duplex:"half",priority:"high"})}catch(e){let t="Error while modifying the request\n";return t+=e.message,new Response(t,{status:500})}try{newRequest.method,newRequest.url,[...newRequest.headers].reduce(((e,[t,r])=>(e[t]=r,e)),{}),newRequest.referrer,newRequest.referrerPolicy,newRequest.mode,newRequest.credentials,newRequest.cache,newRequest.redirect,newRequest.integrity,newRequest.keepalive,newRequest.isReloadNavigation,newRequest.isHistoryNavigation,newRequest.signal,newRequest.duplex}catch(e){let t="Error while constructing the response\n";return t+=e.message,new Response(t,{status:500})}return new Response(JSON.stringify(responseDetails,null,2),{headers:{"Content-Type":"application/json"}})}(r):s.startsWith("/5-response")?async function(e){const t="https://example.com",r={key:"value"},s=new Headers({"X-Custom-Header":"Test"});try{const e=new Response("body content",{status:200,statusText:"OK",headers:s});if(200!==e.status)throw new Error("Status should be 200");if("OK"!==e.statusText)throw new Error('Status text should be "OK"');if("Test"!==e.headers.get("X-Custom-Header"))throw new Error("Custom header should be set")}catch(e){let t="Error while basic construction of response\n";return t+=e.message,new Response(t,{status:500})}try{const e=Response.error();if("error"!==e.type)throw new Error('Response type should be "error"');if(0!==e.status)throw new Error("Status for error response should be 0")}catch(e){let t="Error while testing error response\n";return t+=e.message,new Response(t,{status:500})}try{const e=Response.redirect(t,301);if(301!==e.status)throw new Error("Redirect status should be 301");if(e.headers.get("Location")!==t)throw new Error("Location header should match the test URL")}catch(e){let t="Error while testing redirect response\n";return t+=e.message,new Response(t,{status:500})}try{const e=Response.json(r),t=await e.json();if(JSON.stringify(t)!==JSON.stringify(r))throw new Error("Body data should match the test data")}catch(e){let t="Error while testing JSON response\n";return t+=e.message,new Response(t,{status:500})}return new Response("All tests passed",{headers:{"Content-Type":"text/plain"}})}():s.startsWith("/6-text-encoder")?async function(e){try{const e=new TextEncoder;if(!e)throw new Error("TextEncoder constructor does not create an object.");if(console.log("Passed: TextEncoder constructor creates an object as expected."),"utf-8"!==e.encoding)throw new Error(`Failed: TextEncoder 'encoding' attribute is not 'utf-8', it is '${e.encoding}'.`);console.log("Passed: TextEncoder 'encoding' attribute is 'utf-8' as expected.");const t="Hello, world!";if(!(e.encode(t)instanceof Uint8Array))throw new Error("Failed: TextEncoder 'encode' method does not return a Uint8Array.");console.log("Passed: TextEncoder 'encode' method returns a Uint8Array as expected.");const r="Hello, world!";let s=new Uint8Array(3*r.length);const o=e.encodeInto(r,s);throw"number"==typeof o.read&&"number"==typeof o.written?new Error("Passed: TextEncoder 'encodeInto' method returns an object with 'read' and 'written' properties as expected."):new Error("Failed: TextEncoder 'encodeInto' method does not return the expected object.")}catch(e){return new Response(e.message,{status:500})}}():s.startsWith("/7-text-decoder")?e():s.startsWith("/8-url")?async function(e){try{const e=new URL("https://example.org/foo?bar=baz#qux");if(!e)throw new Error("URL constructor does not create an object.");if(console.log("Passed: URL constructor creates an object as expected."),"https:"!==e.protocol)throw new Error(`Failed: URL 'protocol' attribute is not 'https:', it is '${e.protocol}'.`);if(console.log("Passed: URL 'protocol' attribute is 'https:' as expected."),"example.org"!==e.host)throw new Error(`Failed: URL 'host' attribute is not 'example.org', it is '${e.host}'.`);if(console.log("Passed: URL 'host' attribute is 'example.org' as expected."),"/foo"!==e.pathname)throw new Error(`Failed: URL 'pathname' attribute is not '/foo', it is '${e.pathname}'.`);if(console.log("Passed: URL 'pathname' attribute is '/foo' as expected."),"?bar=baz"!==e.search)throw new Error(`Failed: URL 'search' attribute is not 'bar=baz', it is '${e.search}'.`);if(console.log("Passed: URL 'search' attribute is 'bar=baz' as expected."),"#qux"!==e.hash)throw new Error(`Failed: URL 'hash' attribute is not 'qux', it is '${e.hash}'.`);if(console.log("Passed: URL 'hash' attribute is 'qux' as expected."),"baz"!==e.searchParams.get("bar"))throw new Error(`Failed: URLSearchParams 'get' method does not return 'baz', it returns '${searchParams.get("bar")}'.`);console.log("Passed: URLSearchParams 'get' method returns 'baz' as expected.");try{if(!e.toJSON())throw new Error("URL 'toJSON' method does not return an object.")}catch(e){throw new Error("Failed: URL 'toJSON' method does not return a json object.")}try{const e=new URL("/path","https://example.com");console.log(`Base URL: ${e.href}`)}catch(e){throw new Error("Failed: URL constructor does not create an object with a base.")}try{const e=new URL("https://example.com/base"),t=new URL("path",e);console.log(`New URL using base: ${t.href}`)}catch(e){throw new Error("Failed: URL constructor does not create an object with URL as its base.")}try{const e=new URL("https://example.org/ðŸ’©");console.log(`Unicode pathname: ${e.pathname}`)}catch(e){throw new Error("Failed: URL constructor does not create an object with unicode characters.")}try{new URL("/path")}catch(e){console.log("Caught exception for relative URL without base:",e.message)}return new Response("All tests passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}}():s.startsWith("/10-atob-btoa")?async function(e){const t=(e,t)=>{if(!e)throw new Error(t||"Assertion failed")},r=(e,r,s)=>{t(e===r,s||`Expected ${r} but got ${e}`)};try{const e="Hello, world!",s="SGVsbG8sIHdvcmxkIQ==";r(btoa(e),s,"btoa did not encode the string correctly"),r(atob(s),e,"atob did not decode the string correctly");try{btoa("\0"),t(!0,"btoa handled binary data without throwing error")}catch(e){t(!1,"btoa should not throw error with binary data")}try{atob("Invalid base64 string"),t(!1,"atob should throw error with invalid base64 input")}catch(e){t(!0,"atob threw error as expected with invalid base64 input")}return new Response("All Tests Passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}}():s.startsWith("/11-fetch")?async function(e){const t=(e,t)=>{if(!e)throw new Error(t||"Assertion failed")},r=(e,r,s)=>{t(e===r,s||`Expected ${r} but got ${e}`)};try{const e="http://localhost:3000";try{const t="GET",s=await fetch(e,{method:t});r(s.status,200,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.text();r(o,"GET request successful",`Unexpected response body for ${t} request. Expected 'GET request successful' but got ${o}`)}catch(e){t(!1,`GET request failed: ${e}`)}try{const t="POST",s=await fetch(e,{method:t,headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({name:"Winter"})});r(s.status,201,`Status code mismatch for ${t}, expected 201 but got ${s.status}`);const o=await s.json(),n={name:"Winter"};r(JSON.stringify(o),JSON.stringify(n),`Unexpected response body for ${t} request. Expected { name: 'Winter' } but got ${o}`)}catch(e){t(!1,`POST request failed: ${e}`)}try{const t="PUT",s=await fetch(e,{method:t,headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({name:"Winter"})});r(s.status,201,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.json(),n={name:"Winter"};r(JSON.stringify(o),JSON.stringify(n),`Unexpected response body for ${t} request. Expected { name: 'Winter' } but got ${o}`)}catch(e){t(!1,`PUT request failed: ${e}`)}try{const t="PATCH",s=await fetch(e,{method:t,headers:{"Content-Type":"application/json"},body:JSON.stringify({name:"Winter"})});r(s.status,201,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.json(),n={name:"Winter"};r(JSON.stringify(o),JSON.stringify(n),`Unexpected response body for ${t} request. Expected { name: 'Winter' } but got ${o}`)}catch(e){t(!1,`PATCH request failed: ${e}`)}try{const t="DELETE",s=await fetch(e,{method:t});r(s.status,200,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.text();r(o,"DELETE request successful",`Unexpected response body for ${t} request. Expected 'DELETE request successful' but got ${o}`)}catch(e){t(!1,`DELETE request failed: ${e}`)}try{const t="HEAD",s=await fetch(e,{method:t});r(s.status,200,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.text();r(o,"",`Unexpected response body for ${t} request. Expected empty string but got ${o}`)}catch(e){t(!1,`HEAD request failed: ${e}`)}try{const t="TRACE",s=await fetch(e+"?name=Winter",{method:t});r(s.status,200,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.text();r(o,"name=Winter",`Unexpected response body for ${t} request. Expected 'name=Winter' but got ${o}`)}catch(e){t(!1,`TRACE request failed: ${e}`)}try{const t="OPTIONS",s=await fetch(e,{method:"OPTIONS"});r(s.status,200,`Status code mismatch for ${t}, expected 200 but got ${s.status}`);const o=await s.text();r(o,"",`Unexpected response body for ${t} request. Expected empty string but got ${o}`),r(s.headers.get("allow"),"GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE",`Allow header is incorrect for ${t} request. Expected 'GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE' but got ${s.headers.get("allow")}`)}catch(e){t(!1,`OPTIONS request failed: ${e}`)}return new Response("All Tests Passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}}():s.startsWith("/12-streams")?async function(e){const t=(e,t)=>{if(!e)throw new Error(t||"Assertion failed")},r=(e,r,s)=>{t(e===r,s||`Expected ${r} but got ${e}`)};try{try{const e=new ReadableStream({start(e){e.enqueue("Hello, "),e.enqueue("Wasmer!"),e.close()}}).getReader();let t="";for(;;){const{done:r,value:s}=await e.read();if(r)break;t+=s}r(t,"Hello, Wasmer!",`Unexpected result from readable stream. Expected 'Hello, Wasmer!' but got ${t}`)}catch(e){t(!1,`ReadableStream test failed: ${e}`)}try{let e="";const t=new WritableStream({write(t){e+=t},close(){e+="!"}}).getWriter();t.write("Hello,"),t.write(" "),t.write("Wasmer"),await t.close(),r(e,"Hello, Wasmer!",`Unexpected result from writable stream. Expected 'Hello, Wasmer!' but got ${e}`)}catch(e){t(!1,`WritableStream test failed: ${e}`)}return new Response("All Tests Passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}}():s.startsWith("/13-transform-stream")?t():s.startsWith("/14-more-streams")?async function(e){const t=(e,t)=>{if(!e)throw new Error(t||"Assertion failed")},r=(e,r,s)=>{t(e===r,s||`Expected ${r} but got ${e}`)};try{try{const e=new ReadableStream({start(e){e.enqueue("X"),e.enqueue("Y")},cancel(e){r(e,"Stream canceled",`Stream cancellation reason mismatch. Expected 'Stream canceled' but got ${e}`)}}).getReader();await e.cancel("Stream canceled");const t=await e.read(),s=JSON.stringify(t);r(s,JSON.stringify({done:!0}),`Stream cancellation test failed. Expected { done: true } but got ${s}`)}catch(e){t(!1,`ReadableStream cancellation test failed: ${e}`)}try{const e=new ReadableStream({start(e){e.enqueue("1"),e.error(new Error("Stream error"))}}),t=new TransformStream({transform(e,t){t.enqueue(e+" transformed")}}),s=[];try{const r=e.pipeThrough(t).getReader();for(;;)await r.read()}catch(e){s.push(e.message)}r(s[0],"Stream error",`Error propagation test failed. Expected 'Stream error' but got ${s[0]}`)}catch(e){t(!1,`Stream error propagation test failed: ${e}`)}return new Response("All Tests Passed!",{headers:{"content-type":"text/plain"}})}catch(e){return new Response(e.message,{status:500})}}():new Response(`Route Not Found - ${s}`,{status:404})}addEventListener("fetch",(e=>{e.respondWith(r(e.request))}));
